PRÁCTICA 3: "ORDENACIÓN POR MONTÍCULOS"
AUTOR: Iván Castro Roel                 LOGIN: ivan.castro.roel
AUTOR: Alejandro Amado Fernández        LOGIN: alejandro.amado
AUTOR: Leandro Malo Balboa              LOGIN: leandro.mbalboa
GRUPO: 4.3
FECHA: 02/11/2023	

Práctica realizada en:
-Ordenador portátil:
 SO: Ubuntu 22.04.3 LTS
 CPU: Intel core i7-9750h            2.60 GHz
 RAM: 32GB
 GPU: NVIDIA GeForce RTX 2060
 

Esta practica tiene por objetivo determinar el tiempo de ejecución de 
un algoritmo: El algoritmo de ordenación por montículos. Este algoritmo se
encarga de ordenar ascendentemente un vector de n números enteros, que
previamente pueden estar ordenados aleatoriamente, descendentemente o 
ascendentemente. El analisis de los resultados se hizo a través de una 
comprobación empírica de la complejidad. Además, también será objeto de 
estudio la complejidad de la operación que se encarga de crear un montículo

Todas las mediciones presentes en este informe han sido realizadas en 
microsegundos (µs).Para ello nos hemos apoyado en la función microsegundos().

Para un correcto estudio de los tiempos de dichos algoritmos hemos empleado 
arrays con datos de entrada que siguen una progresión geométrica de razón 2. 
Los tamaños de entrada empleados en el estudio son: 4000, 8000, 16000, 
32000, 64000 y 128000, 256000 elementos respectivamente.

---------------------
Tablas de Resultados
---------------------


A continuación se mostrarán una serie de tablas con los resultados obtenidos
en nuestro estudio para la ejecución del algoritmo, en dichas tablas se
mostrará la siguiente información: El tamaño del array empleado (n), el tiempo 
medio de ejecución (t(n)), la cota subestimada, ajustada y sobreestimada. 

También es importante destacar que para el correcto estudio de dichas 
funciones se ha decidido que para aquellas mediciones de menos de 500 µs se 
ha decidido realizar 1000 iteraciones y calculado su promedio.

-------Creación de un montículo-------

Tiempos de ejecución (crear, aleatorio)

         Tamaño           t(n)  (t(n)/n^0.82)  (t(n)/n^1.02)  (t(n)/n^1.22)
(*)        4000         55.774       0.062050       0.011812       0.002249
(*)        8000        114.466       0.072134       0.011954       0.001981
(*)       16000        226.744       0.080939       0.011677       0.001685
(*)       32000        433.440       0.087641       0.011007       0.001382
          64000        927.000       0.106173       0.011609       0.001269
         128000       1847.000       0.119827       0.011405       0.001086
         256000       3769.000       0.138506       0.011477       0.000951

(*) -> Tiempo medio para 1000 iteraciones

Cota subestimada: n^0.82
Cota ajustada: n^1.02
Cota sobrestimada: n^1.22


Los valores de dividir el tiempo entre la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre la cota ajustada tienden a 
la constante '0.011'.

Los valores de dividir el tiempo entre la cota sobrestimada tienden a 0 
a medida que aumenta n.


Tiempos de ejecución (crear, descendente)

         Tamaño           t(n)  (t(n)/n^0.82)  (t(n)/n^1.02)  (t(n)/n^1.22)
(*)        4000         32.729       0.036412       0.006932       0.001320
(*)        8000         65.918       0.041540       0.006884       0.001141
(*)       16000        133.080       0.047504       0.006853       0.000989
(*)       32000        265.798       0.053744       0.006750       0.000848
          64000        557.000       0.063795       0.006975       0.000763
         128000       1127.000       0.073116       0.006959       0.000662
         256000       2298.000       0.084449       0.006998       0.000580

(*) -> Tiempo medio para 1000 iteraciones

Cota subestimada: n^0.82
Cota ajustada: n^1.02
Cota sobrestimada: n^1.22


Los valores de dividir el tiempo entre la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre la cota ajustada tienden a 
la constante '0.0069'.

Los valores de dividir el tiempo entre la cota sobrestimada tienden a 0 
a medida que aumenta n.


Tiempos de ejecución (crear, ascendente)

         Tamaño           t(n)  (t(n)/n^0.84)  (t(n)/n^1.04)  (t(n)/n^1.24)
(*)        4000         15.198       0.014324       0.002727       0.000519
(*)        8000         31.110       0.016380       0.002714       0.000450
(*)       16000         61.094       0.017970       0.002592       0.000374
(*)       32000        120.168       0.019745       0.002480       0.000311
(*)       64000        241.484       0.022167       0.002424       0.000265
         128000        562.000       0.028819       0.002743       0.000261
         256000       1157.000       0.033145       0.002746       0.000228

(*) -> Tiempo medio para 1000 iteraciones

Cota subestimada: n^0.84
Cota ajustada: n^1.04
Cota sobrestimada: n^1.24


Los valores de dividir el tiempo entre la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre la cota ajustada tienden a 
la constante '0.0027'.

Los valores de dividir el tiempo entre la cota sobrestimada tienden a 0 
a medida que aumenta n.

-------Ordenación por montículos-------

Tiempos de ejecución (monticulo, aleatorio)

         Tamaño           t(n)   (t(n)/n^0.9)   (t(n)/n^1.1)   (t(n)/n^1.3)
(*)        4000        435.811       0.249715       0.047537       0.009049
           8000        969.000       0.297538       0.049309       0.008172
          16000       1974.000       0.324817       0.046861       0.006761
          32000       4316.000       0.380580       0.047799       0.006003
          64000       9566.000       0.452031       0.049423       0.005404
         128000      20713.000       0.524510       0.049924       0.004752
         256000      43972.000       0.596706       0.049444       0.004097

(*) -> Tiempo medio para 1000 iteraciones 


Cota subestimada: n^0.9
Cota ajustada: n^1.1
Cota sobrestimada: n^1.3


Los valores de dividir el tiempo entre la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre la cota ajustada tienden a 
la constante '0.049'.

Los valores de dividir el tiempo entre la cota sobrestimada tienden a 0 
a medida que aumenta n.


Tiempos de ejecución (monticulo, descendente)

         Tamaño           t(n)  (t(n)/n^0.88)  (t(n)/n^1.08)  (t(n)/n^1.28)
(*)        4000        378.826       0.256228       0.048777       0.009285
           8000        796.000       0.292546       0.048481       0.008034
          16000       1672.000       0.333895       0.048171       0.006950
          32000       3514.000       0.381302       0.047889       0.006015
          64000       7403.000       0.436485       0.047724       0.005218
         128000      15616.000       0.500293       0.047619       0.004533
         256000      32623.000       0.567901       0.047057       0.003899

(*) -> Tiempo medio para 1000 iteraciones 


Cota subestimada: n^0.88
Cota ajustada: n^1.08
Cota sobrestimada: n^1.28


Los valores de dividir el tiempo entre la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre la cota ajustada tienden a 
la constante '0.047'.

Los valores de dividir el tiempo entre la cota sobrestimada tienden a 0 
a medida que aumenta n.



Tiempos de ejecución (monticulo, ascendente)

         Tamaño           t(n)  (t(n)/n^0.88)  (t(n)/n^1.08)  (t(n)/n^1.28)
(*)        4000        366.250       0.247722       0.047158       0.008977
           8000        778.000       0.285930       0.047385       0.007853
          16000       1637.000       0.326906       0.047163       0.006804
          32000       3454.000       0.374792       0.047072       0.005912
          64000       7308.000       0.430884       0.047111       0.005151
         128000      15418.000       0.493950       0.047015       0.004475
         256000      32081.000       0.558466       0.046275       0.003834

(*) -> Tiempo medio para 1000 iteraciones 


Cota subestimada: n^0.88
Cota ajustada: n^1.08
Cota sobrestimada: n^1.28


Los valores de dividir el tiempo entre el la cota subestimada tienden 
a infinito a medida que aumenta n.

Los valores de dividir el tiempo entre el la cota ajustada tienden a 
la constante '0.0465'.

Los valores de dividir el tiempo entre el la cota sobrestimada tienden a 0 
a medida que aumenta n.


--------------
Conclusiones
--------------

En esta práctica, hemos estudiado el algoritmo de ordenación por montículos
y su rendimiento en diferentes escenarios. Hemos observado que el algoritmo
se comporta de manera eficiente en la mayoría de los casos, y su complejidad
computacional se ajusta a las cotas propuestas, siendo de O(n*log(n)). Sin
embargo, hemos notado que el rendimiento del algoritmo es especialmente 
destacable cuando se aplica a conjuntos de datos más grandes. A medida que 
aumenta el tamaño del vector de entrada, el tiempo de ejecución tiende a 
aumentar, pero sigue siendo razonablemente rápido.

En el caso de conjuntos de datos aleatorios, hemos observado que el tiempo de 
ejecución es mayor en comparación con los conjuntos ordenados ascendentemente
o descendentemente, aunque es una diferencia bastante pequeña, sobre todo en 
comparación con los otros algoritmos vistos. Esto sugiere que el algoritmo de 
ordenación por montículos puede beneficiarse de datos preordenados. En general, 
hemos visto que las cotas subestimadas, ajustadas y sobrestimadas proporcionan 
una buena estimación del comportamiento del algoritmo en diferentes 
situaciones.
